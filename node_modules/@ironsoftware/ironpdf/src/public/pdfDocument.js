"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PdfDocument = void 0;
const buffer_1 = require("buffer");
const types_1 = require("./types");
const fs = __importStar(require("fs"));
const util_1 = require("../internal/grpc_layer/util");
const io_1 = require("../internal/grpc_layer/pdfium/io");
const render_1 = require("../internal/grpc_layer/chrome/render");
const image_1 = require("../internal/grpc_layer/chrome/image");
const image_2 = require("../internal/grpc_layer/pdfium/image");
const jimp_1 = __importDefault(require("jimp"));
const page_1 = require("../internal/grpc_layer/pdfium/page");
const security_1 = require("../internal/grpc_layer/pdfium/security");
const stamp_1 = require("../internal/grpc_layer/chrome/stamp");
const pdfa_1 = require("../internal/grpc_layer/pdfium/pdfa");
const compress_1 = require("../internal/grpc_layer/pdfium/compress");
const signing_1 = require("../internal/grpc_layer/pdfium/signing");
const headerFooter_1 = require("../internal/grpc_layer/pdfium/headerFooter");
const BackgroundForeground_1 = require("../internal/grpc_layer/pdfium/BackgroundForeground");
const text_1 = require("../internal/grpc_layer/pdfium/text");
const metadata_1 = require("../internal/grpc_layer/pdfium/metadata");
const access_1 = require("../internal/access");
/**
 * Represents a PDF document. Allows: loading, editing, manipulating, merging, signing printing and saving PDFs.
 *
 * @remark Make sure that you call {@link PdfDocument.close} or {@link cleanUp} to free the memory, when you stop using the PdfDocument object.
 */
class PdfDocument {
    /**
     * Create a PdfDocument object from a {@link PdfInput}
     * For more specific way to create/open PdfDocment see {@link fromUrl} {@link fromZip} {@link fromHtml} {@link fromImage}  {@link open}
     *
     * @param pdfInput see {@link PdfInput} (required)
     * @param password a password to open the PDF required if PDF file was protected (pdfInput is {@link PdfFilePath} or {@link Buffer})
     */
    constructor(pdfInput, password) {
        var _a;
        if (pdfInput) {
            this.pdfDocumentId = undefined;
            const input = (0, util_1.separatePdfInput)(pdfInput);
            switch (input.type) {
                case "htmlFile":
                    const htmlString = fs
                        .readFileSync(input.htmlFile)
                        .toString();
                    this.promiseDocumentId = (0, render_1.renderHtmlToPdf)(htmlString);
                    break;
                case "htmlString":
                    this.promiseDocumentId = (0, render_1.renderHtmlToPdf)(input.htmlString);
                    break;
                case "zipFile":
                    this.promiseDocumentId = (0, render_1.renderHtmlZipToPdf)(input.zipFile);
                    break;
                case "buffer":
                    this.promiseDocumentId = (0, io_1.openPdfFileBuffer)(input.buffer, password);
                    break;
                case "pdfFile":
                    this.pdfPassword = password;
                    this.promiseDocumentId = (0, io_1.openPdfFileBuffer)(fs.readFileSync(input.pdfFile), password);
                    break;
                case "url":
                    this.promiseDocumentId = (0, render_1.renderUrlToPdf)(input.url);
                    break;
                case "pdfDocument":
                    this.pdfDocumentId = input.pdfDocument.pdfDocumentId;
                    this.promiseDocumentId =
                        input.pdfDocument.promiseDocumentId;
                    break;
            }
            if (this.pdfDocumentId) {
                access_1.Access.usedDocumentIds.add(this.pdfDocumentId);
            }
            (_a = this.promiseDocumentId) === null || _a === void 0 ? void 0 : _a.then((id) => access_1.Access.usedDocumentIds.add(id));
        }
    }
    /**
     * Dispose this PdfDocument object (clean up the resource)
     * This is necessary to free the memory used by PdfDocument. See {@link cleanUp}
     * Once this method was called this PdfDocument object no longer usable.
     */
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, io_1.disposePdf)(yield this.getId());
        });
    }
    /**
     * @private
     */
    getId() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.pdfDocumentId) {
                return this.pdfDocumentId;
            }
            else if (this.promiseDocumentId) {
                this.pdfDocumentId = yield this.promiseDocumentId;
                return this.pdfDocumentId;
            }
            else {
                throw new Error("Cannot Get PdfDocumentId");
            }
        });
    }
    //#region io
    /**
     * Open or Create a PdfDocument from a {@link PdfInput}
     * @param pdfInput {@link PdfInput}
     * @param options including {@link PdfPassword} {@link ChromePdfRenderOptions} {@link HttpLoginCredentials} mainHtmlFile
     */
    static open(pdfInput, options) {
        return __awaiter(this, void 0, void 0, function* () {
            if (pdfInput) {
                const input = (0, util_1.separatePdfInput)(pdfInput);
                switch (input.type) {
                    case "htmlFile":
                        const htmlString = fs
                            .readFileSync(input.htmlFile)
                            .toString();
                        const newHtmlFilePdf = new PdfDocument();
                        newHtmlFilePdf.pdfDocumentId = yield (0, render_1.renderHtmlToPdf)(htmlString, options === null || options === void 0 ? void 0 : options.renderOptions);
                        return newHtmlFilePdf;
                    case "htmlString":
                        const newHtmlStringPdf = new PdfDocument();
                        newHtmlStringPdf.pdfDocumentId = yield (0, render_1.renderHtmlToPdf)(input.htmlString, options === null || options === void 0 ? void 0 : options.renderOptions);
                        return newHtmlStringPdf;
                    case "zipFile":
                        const newZipFilePdf = new PdfDocument();
                        newZipFilePdf.pdfDocumentId = yield (0, render_1.renderHtmlZipToPdf)(input.zipFile, options === null || options === void 0 ? void 0 : options.mainHtmlFile, options === null || options === void 0 ? void 0 : options.renderOptions);
                        return newZipFilePdf;
                    case "buffer":
                        const newBufferPdf = new PdfDocument(undefined, options === null || options === void 0 ? void 0 : options.password);
                        newBufferPdf.pdfDocumentId = yield (0, io_1.openPdfFileBuffer)(input.buffer, options === null || options === void 0 ? void 0 : options.password);
                        return newBufferPdf;
                    case "pdfFile":
                        const newPdfFilePdf = new PdfDocument(undefined, options === null || options === void 0 ? void 0 : options.password);
                        newPdfFilePdf.pdfDocumentId = yield (0, io_1.openPdfFileBuffer)(fs.readFileSync(input.pdfFile), options === null || options === void 0 ? void 0 : options.password);
                        return newPdfFilePdf;
                    case "url":
                        const newUrlPdf = new PdfDocument();
                        newUrlPdf.pdfDocumentId = yield (0, render_1.renderUrlToPdf)(input.url, {
                            renderOptions: options === null || options === void 0 ? void 0 : options.renderOptions,
                            httpLoginCredentials: options === null || options === void 0 ? void 0 : options.httpLoginCredentials,
                        });
                        return newUrlPdf;
                    case "pdfDocument":
                        return Promise.resolve(input.pdfDocument);
                }
            }
            throw new Error(`cannot create PdfDocument object from ${pdfInput}`);
        });
    }
    /**
     * Open a PdfDocument from .pdf file
     * @param pdfFilePath A path to .pdf file
     */
    static fromFile(pdfFilePath) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.open(pdfFilePath);
        });
    }
    /**
     * Create a PdfDocument from an Url
     * @param url A website Url
     * @param options including {@link ChromePdfRenderOptions}
     */
    static fromUrl(url, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.open(url, options);
        });
    }
    /**
     * Creates a PDF file from a local Zip file, and returns it as a {@link PdfDocument}.
     * IronPDF is a W3C standards compliant HTML rendering based on Google's Chromium browser.
     * If your output PDF does not look as expected:
     *
     * - Validate your HTML file using  https://validator.w3.org/ &amp; CSS https://jigsaw.w3.org/css-validator/
     *
     * - To debug HTML, view the file in Chrome web browser's print preview which will work almost exactly as IronPDF.
     *
     * - Read our detailed documentation on pixel perfect HTML to PDF: https://ironpdf.com/tutorials/pixel-perfect-html-to-pdf/
     *
     * @param zipFilePath Path to a Zip to be rendered as a PDF.
     * @param options including {@link ChromePdfRenderOptions} and `mainHtmlFile` a main .html file default: `index.html`
     */
    static fromZip(zipFilePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.open(zipFilePath, options);
        });
    }
    /**
     * Creates a PDF file from a Html string, and returns it as an {@link PdfDocument} object which can be edited and saved to disk or served on a website.
     * @param htmlStringOrHtmlFilePath The Html to be rendered as a PDF.
     * @param options including {@link ChromePdfRenderOptions}
     */
    static fromHtml(htmlStringOrHtmlFilePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.open(htmlStringOrHtmlFilePath, options);
        });
    }
    /**
     *  Converts multiple image files to a PDF document.  Each image creates 1 page which matches the image
     *  dimensions. The default PaperSize is A4. You can set it via ImageToPdfConverter.PaperSize.
     *  Note: Imaging.ImageBehavior.CropPage will set PaperSize equal to ImageSize.
     * @param images The image file path name(s) or {@link ImageBuffer} object(s)
     * @param options including {@link ImageToPdfOptions}
     */
    static fromImage(images, options) {
        return __awaiter(this, void 0, void 0, function* () {
            let temp;
            if (Array.isArray(images)) {
                // const imageArray = images as Array<any>;
                if (images.length == 0) {
                    throw new Error("imageToPdf input Array is Empty");
                }
                const t = (0, util_1.separateImageBufferOrImagePathInput)(images[0]);
                switch (t.type) {
                    case "imageBuffer":
                        temp = (0, image_1.renderImagesBufferToPdf)(images, options === null || options === void 0 ? void 0 : options.imageToPdfOptions);
                        break;
                    case "imageFilePath":
                        temp = (0, image_1.renderImagesFilesToPdf)(images, options === null || options === void 0 ? void 0 : options.imageToPdfOptions);
                        break;
                }
            }
            else {
                const image = (0, util_1.separateImageBufferOrImagePathInput)(images);
                switch (image.type) {
                    case "imageBuffer":
                        temp = (0, image_1.renderImagesBufferToPdf)([image.imageBuffer], options === null || options === void 0 ? void 0 : options.imageToPdfOptions);
                        break;
                    case "imageFilePath":
                        temp = (0, image_1.renderImagesFilesToPdf)([image.imageFilePath], options === null || options === void 0 ? void 0 : options.imageToPdfOptions);
                        break;
                }
            }
            if (!temp) {
                throw new Error(`cannot read image: ${images}`);
            }
            const newUrlPdf = new PdfDocument();
            newUrlPdf.pdfDocumentId = yield temp;
            return newUrlPdf;
        });
    }
    /**
     * Static method that joins (concatenates) multiple PDF documents together into one compiled PDF document.
     * If the PDF contains form fields the form field in the resulting PDF's name will be appended with '_{index}' e.g. 'Name' will be 'Name_0'
     * @param pdfs array of PDF
     */
    static mergePdf(pdfs) {
        return __awaiter(this, void 0, void 0, function* () {
            const ids = yield Promise.all(pdfs.map((x) => __awaiter(this, void 0, void 0, function* () { return (yield PdfDocument.open(x)).getId(); })));
            const newDocId = (0, render_1.mergePdfs)(ids);
            const newUrlPdf = new PdfDocument();
            newUrlPdf.pdfDocumentId = yield newDocId;
            return newUrlPdf;
        });
    }
    /**
     * Saves the PdfDocument to a file.
     * @param filePath Target file path
     * @param saveOptions see {@link SaveOptions}
     */
    saveAs(filePath, saveOptions) {
        return this.saveAsBuffer(saveOptions).then((pdfFileBuffer) => {
            fs.writeFile(filePath, pdfFileBuffer, "binary", (err) => {
                if (err)
                    throw err;
            });
        });
    }
    /**
     * Saves the PdfDocument to a binary (Buffer)
     * @param saveOptions see {@link SaveOptions}
     */
    saveAsBuffer(saveOptions) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, io_1.getBinaryData)(yield this.getId(), saveOptions);
        });
    }
    //#endregion
    //#region compress
    /**
     * Compress existing PDF images using JPG encoding and the specified settings
     * @param imageQuality Quality (1 - 100) to use during compression
     * @param scaleToVisibleSize Scale down the image resolution according to its visible size in the PDF document
     */
    compressSize(imageQuality, scaleToVisibleSize = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (imageQuality < 1 || imageQuality > 100)
                throw new Error(`Invalid quality specifier (${imageQuality}) when compressing images. Quality must be between 1 and 100.`);
            return yield (0, compress_1.compressImage)(yield this.getId(), imageQuality, scaleToVisibleSize);
        });
    }
    //#endregion
    //#region page
    /**
     * Gets information of all pages in the PdfDocument
     */
    getPagesInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, page_1.getPageInfo)(yield this.getId());
        });
    }
    /**
     * Gets the number of pages in the PdfDocument.
     */
    getPageCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.getPagesInfo()).length;
        });
    }
    /**
     * Set the page orientation.
     * @param pageRotation see {@link PageRotation}
     * @param options including {@link PdfPageSelection}
     */
    setRotation(pageRotation, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, page_1.setPageRotation)(yield this.getId(), pageRotation, options);
        });
    }
    /**
     * Resize a page to the specified dimensions
     * @param newSize {@link PdfPaperSize}
     * @param options including {@link PdfPageSelection}
     */
    resize(newSize, options) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, page_1.resizePage)(yield this.getId(), newSize, options);
        });
    }
    /**
     * Adds another PDF to the beginning of the current PdfDocument
     * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
     * @param fromPdfDocument PdfDocument to prepend
     */
    prependAnotherPdf(fromPdfDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.insertPagesFromAnotherPdf(fromPdfDocument, 0);
        });
    }
    /**
     * Appends another PDF to the end of the current <see cref="PdfDocument"/>
     * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
     * @param fromPdfDocument PdfDocument to Append
     */
    appendAnotherPdf(fromPdfDocument) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.insertPagesFromAnotherPdf(fromPdfDocument, (yield this.getPageCount()) - 1);
        });
    }
    /**
     * Inserts another PDF into the current PdfDocument, starting at a given Page Index.
     * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
     * @param fromPdfDocument Another PdfDocument
     * @param insertAtPageIndex Index at which to insert the new content.  Note: Page 1 has index 0...
     */
    insertPagesFromAnotherPdf(fromPdfDocument, insertAtPageIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, page_1.insertPdf)(yield this.getId(), yield fromPdfDocument.getId(), insertAtPageIndex);
        });
    }
    /**
     * Removes a range of pages from the PDF
     * @param pages pages to remove
     */
    removePage(pages) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, page_1.removePage)(yield this.getId(), { PdfPageSelection: pages });
        });
    }
    /**
     * Creates a new PDF by copying a range of pages from this {@link PdfDocument}.
     * @param pages pages to copy (default "all")
     */
    duplicate(pages = "all") {
        return __awaiter(this, void 0, void 0, function* () {
            const newPdf = new PdfDocument();
            newPdf.pdfDocumentId = yield (0, page_1.duplicate)(yield this.getId(), {
                PdfPageSelection: pages,
            });
            return newPdf;
        });
    }
    //#endregion
    //#region image
    /**
     * Finds all embedded Images from within a specified pages in the PDF and returns them as Buffer
     * @param options including {@link PdfPageSelection}
     */
    extractRawImages(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (0, image_2.extractRawImages)(yield this.getId(), (_a = options === null || options === void 0 ? void 0 : options.fromPages) !== null && _a !== void 0 ? _a : "all");
        });
    }
    /**
     * Renders the PDF and exports image Files in convenient formats. 1 image file is created for each
     * page.
     *
     * @param options including {@link PdfPageSelection} {@link ImageType}
     *
     * @return array of images as Buffer[]
     */
    rasterizeToImageBuffers(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const images = yield (0, image_2.rasterizeToImageBuffers)(yield this.getId(), (_a = options === null || options === void 0 ? void 0 : options.fromPages) !== null && _a !== void 0 ? _a : "all");
            const jimpImageType = (() => {
                switch (options === null || options === void 0 ? void 0 : options.imageType) {
                    case types_1.ImageType.BMP:
                        return jimp_1.default.MIME_BMP;
                    case types_1.ImageType.PNG:
                        return jimp_1.default.MIME_PNG;
                    case types_1.ImageType.JPG:
                        return jimp_1.default.MIME_JPEG;
                    default:
                        return jimp_1.default.MIME_PNG;
                }
            })();
            return Promise.all(images.map((imageBuffer) => __awaiter(this, void 0, void 0, function* () {
                //convert output type
                const jimp = yield jimp_1.default.read(imageBuffer);
                return yield jimp.getBufferAsync(jimpImageType);
            })));
        });
    }
    /**
     * Renders the PDF and exports image Files in convenient formats. 1 image file is created for each
     * page. Running number will append output file path.
     *
     * @param filePath output file path.
     * @param options including {@link PdfPageSelection} {@link ImageType}
     *
     * @return array of images file name as string[]
     */
    rasterizeToImageFiles(filePath, options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const images = yield (0, image_2.rasterizeToImageBuffers)(yield this.getId(), (_a = options === null || options === void 0 ? void 0 : options.fromPages) !== null && _a !== void 0 ? _a : "all");
            const filesName = (0, util_1.getFileNames)(filePath, images.length, (0, util_1.getImageExtType)(options === null || options === void 0 ? void 0 : options.type), "image");
            const promises = images.map((imageBuffer, index) => __awaiter(this, void 0, void 0, function* () {
                yield jimp_1.default.read(imageBuffer).then((value) => value.write(filesName[index]));
                return filesName[index];
            }));
            return yield Promise.all(promises);
        });
    }
    //#endregion
    //#region text
    /**
     * Replace the specified old text with new text on a given page
     * @param oldText Old text to remove
     * @param newText New text to add
     * @param onPages Page index to search for old text to replace (default "all")
     */
    replaceText(oldText, newText, onPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, text_1.replaceText)(yield this.getId(), oldText, newText, onPages);
        });
    }
    extractText(onPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, text_1.extractAllText)(yield this.getId(), onPages);
        });
    }
    //#endregion
    //#region pdfA
    /**
     * Convert the current document into the specified PDF-A standard format
     * @param customICC (Optional) Custom color profile file path
     */
    convertToPdfA(customICC) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, pdfa_1.toPdfA)(yield this.getId(), customICC);
        });
    }
    /**
     * Convert the current document into the specified PDF/UA standard format
     */
    convertToPdfUA() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, pdfa_1.toPdfUA)(yield this.getId());
        });
    }
    //#endregion
    //#region metadata
    /**
     * Gets a Map<string, string> of metadata properties
     */
    getMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, metadata_1.getMetadataDict)(yield this.getId());
        });
    }
    /**
     * Add or Update a single metadata property
     * @param key
     * @param value
     */
    addOrUpdateMetadata(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, metadata_1.setMetadata)(yield this.getId(), key, value);
        });
    }
    /**
     * Remove a single metadata property
     * @param key
     */
    removeMetadata(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, metadata_1.removeMetadata)(yield this.getId(), key);
        });
    }
    /**
     * Sets a whole metadata properties Map<string, string> (override all the metadata property)
     * @param newMetadataDictionary new metadata properties Map<string, string>
     */
    overrideMetadata(newMetadataDictionary) {
        return __awaiter(this, void 0, void 0, function* () {
            return (0, metadata_1.setMetadataDict)(yield this.getId(), newMetadataDictionary);
        });
    }
    //#endregion
    //#region signing
    /**
     * Sign PDF with digital signature certificate.
     * Note that the PDF will not be fully signed until Saved
     * using {@link saveAs} or {@link saveAsBuffer}
     *
     * Multiple certificates may be used.
     * @param signature see {@link DigitalSignature}
     */
    signDigitalSignature(signature) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, signing_1.signPdf)(yield this.getId(), signature);
        });
    }
    /**
     * Check if PdfDocument was signed or not
     */
    isSigned() {
        return __awaiter(this, void 0, void 0, function* () {
            const signatureCount = yield (0, signing_1.getSignatureCount)(yield this.getId());
            return signatureCount > 0;
        });
    }
    /**
     * Count the number signature that signed to this PdfDocument
     */
    signatureCount() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, signing_1.getSignatureCount)(yield this.getId());
        });
    }
    //#endregion
    //#region header/footer (affix)
    /**
     * Apply page header on top of an existing Pdf.
     * @param header {@link TextAffix}
     * @param toPages {@link PdfPageSelection}
     */
    addTextHeader(header, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, headerFooter_1.addTextAffix)(yield this.getId(), toPages, header, true);
        });
    }
    /**
     * Apply page footer on top of an existing Pdf.
     * @param footer {@link TextAffix}
     * @param toPages {@link PdfPageSelection}
     */
    addTextFooter(footer, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, headerFooter_1.addTextAffix)(yield this.getId(), toPages, footer, false);
        });
    }
    /**
     * Apply HTML header on top of an existing Pdf.
     * @param header {@link HtmlAffix}
     * @param toPages {@link PdfPageSelection}
     */
    addHtmlHeader(header, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, headerFooter_1.addHtmlAffix)(yield this.getId(), toPages, header, true);
        });
    }
    /**
     * Apply HTML footer on top of an existing Pdf.
     * @param footer {@link HtmlAffix}
     * @param toPages {@link PdfPageSelection}
     */
    addHtmlFooter(footer, toPages) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, headerFooter_1.addHtmlAffix)(yield this.getId(), toPages, footer, false);
        });
    }
    //#endregion
    //#region stamp
    /**
     * Edits the PDF by applying the HTML's rendered to only selected page(s).
     * @param htmlStringOrHtmlFilePath
     * @param options including {@link HtmlStampOptions} {@link PdfPageSelection}
     */
    stampHtml(htmlStringOrHtmlFilePath, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const html = htmlStringOrHtmlFilePath.endsWith(".html") ||
                htmlStringOrHtmlFilePath.endsWith(".htm")
                ? fs.readFileSync(htmlStringOrHtmlFilePath).toString()
                : htmlStringOrHtmlFilePath;
            yield (0, stamp_1.stampHtml)(yield this.getId(), html, {
                password: this.pdfPassword,
                htmlStampOptions: options === null || options === void 0 ? void 0 : options.htmlStampOptions,
                pageSelection: options === null || options === void 0 ? void 0 : options.toPages,
            });
        });
    }
    /**
     * Edits the PDF by applying the image to only selected page(s).
     * @param image image file path or image buffer
     * @param options including {@link ImageStampOptions} {@link PdfPageSelection}
     */
    stampImage(image, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const imageBuffer = image instanceof buffer_1.Buffer ? image : fs.readFileSync(image);
            yield (0, stamp_1.stampImage)(yield this.getId(), imageBuffer, {
                password: this.pdfPassword,
                options: options === null || options === void 0 ? void 0 : options.imageStampOptions,
                pageSelection: options === null || options === void 0 ? void 0 : options.toPages,
            });
        });
    }
    /**
     * Edits the PDF by applying the text to only selected page(s).
     * @param text text to stamp
     * @param options including {@link TextStampOptions} {@link PdfPageSelection}
     */
    stampText(text, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, stamp_1.stampText)(yield this.getId(), text, {
                password: this.pdfPassword,
                options: options === null || options === void 0 ? void 0 : options.textStampOptions,
                pageSelection: options === null || options === void 0 ? void 0 : options.toPages,
            });
        });
    }
    /**
     * Edits the PDF by applying the barcode to only selected page(s).
     * @param barcodeValue barcode
     * @param options including {@link BarcodeType} {@link BarcodeStampOptions} {@link PdfPageSelection}
     */
    stampBarcode(barcodeValue, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, stamp_1.stampBarcode)(yield this.getId(), barcodeValue, {
                password: this.pdfPassword,
                options: options === null || options === void 0 ? void 0 : options.barcodeStampOptions,
                pageSelection: options === null || options === void 0 ? void 0 : options.toPages,
            });
        });
    }
    //#endregion
    //#region background/foreground
    /**
     * Adds a background to each page of this PDF. The background is copied from a first page in the
     * backgroundPdf document.
     *
     * @param fromPdf background PDF document
     * @param sourcePageIndex Index (zero-based page number) of the page to copy from the Background/Foreground PDF. Default is 0.
     * @param applyToPages  PageSelection to which the background/foreground will be added. Default is "all"
     */
    addBackgroundFromAnotherPdf(fromPdf, sourcePageIndex = 0, applyToPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, BackgroundForeground_1.addBackgroundForeground)(yield this.getId(), yield fromPdf.getId(), sourcePageIndex, true, applyToPages);
        });
    }
    /**
     * Adds a foreground to each page of this PDF. The background is copied from a first page in the
     * backgroundPdf document.
     *
     * @param fromPdf foreground PDF document
     * @param sourcePageIndex Index (zero-based page number) of the page to copy from the Background/Foreground PDF. Default is 0.
     * @param applyToPages  PageSelection to which the background/foreground will be added. Default is "all"
     */
    addForegroundFromAnotherPdf(fromPdf, sourcePageIndex = 0, applyToPages) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, BackgroundForeground_1.addBackgroundForeground)(yield this.getId(), yield fromPdf.getId(), sourcePageIndex, false, applyToPages);
        });
    }
    //#endregion
    //#region security
    /**
     * Removes all user and owner password security for a PDF document.  Also disables content
     * encryption.
     * If content is encrypted at 128 bit, copy and paste of content, annotations and form editing may be disabled.
     */
    removePasswordsAndEncryption() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, security_1.removePasswordsAndEncryption)(yield this.getId());
        });
    }
    /**
     * Sets the user password and enables 128Bit encryption of PDF content.
     * A user password is a password that each user must enter to open or print the PDF document.
     */
    setUserPassword(userPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.pdfPassword)
                this.pdfPassword = { userPassword: userPassword };
            else
                this.pdfPassword.userPassword = userPassword;
            this.pdfDocumentId = yield (0, security_1.setUserPasswords)(yield this.getId(), userPassword);
        });
    }
    /**
     * Sets the owner password and enables 128Bit encryption of PDF content. An owner password is one used to
     * enable and disable all other security settings. <para>OwnerPassword must be set to a non-empty string
     * value for {@link PdfPermission.AllowAccessibilityExtractContent} ,  {@link PdfPermission.AllowAnnotations} ,
     * {@link PdfPermission.AllowFillForms},  {@link PdfPermission.AllowPrint},  {@link PdfPermission.AllowModify} to be
     * restricted.
     */
    setOwnerPassword(ownerPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.pdfPassword)
                this.pdfPassword = { ownerPassword: ownerPassword };
            else
                this.pdfPassword.ownerPassword = ownerPassword;
            this.pdfDocumentId = yield (0, security_1.setOwnerPasswords)(yield this.getId(), ownerPassword);
        });
    }
    /**
     * Sets the permissions of this PdfDocument
     * @param permissions see {@link PdfPermission}
     */
    setPermission(permissions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.pdfDocumentId = yield (0, security_1.setSecurity)(yield this.getId(), permissions);
        });
    }
    /**
     * Gets the current permissions of this PdfDocument
     * @return {@link PdfPermission}
     */
    getPermission() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield (0, security_1.getPermission)(yield this.getId());
        });
    }
    /**
     * Makes this PDF document read only such that: Content is encrypted at 128 bit. Copy and paste of
     * content is disallowed. Annotations and form editing are disabled.
     * @param ownerPassword The owner password for the PDF. A string for owner password is required to enable PDF encryption and
     * all document security options.
     */
    makePdfDocumentReadOnly(ownerPassword) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.setOwnerPassword(ownerPassword);
            yield this.setPermission({
                AllowExtractContent: false,
                AllowAccessibilityExtractContent: false,
                AllowAnnotations: false,
                AllowModify: false,
                AllowAssembleDocument: false,
                AllowFillForms: false,
            });
        });
    }
}
exports.PdfDocument = PdfDocument;
//# sourceMappingURL=pdfDocument.js.map