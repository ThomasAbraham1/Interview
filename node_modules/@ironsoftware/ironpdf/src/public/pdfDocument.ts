import { Buffer } from "buffer";
import {
	BarcodeStampOptions,
	BarcodeType,
	ChromePdfRenderOptions,
	DigitalSignature,
	HtmlAffix,
	HtmlFilePath,
	HtmlStampOptions,
	HtmlString,
	HttpLoginCredentials,
	ImageBuffer,
	ImageFilePath,
	ImageStampOptions,
	ImageToPdfOptions,
	ImageType,
	PageInfo,
	PageRotation,
	PdfInput,
	PdfPageSelection,
	PdfPaperSize,
	PdfPassword,
	PdfPermission,
	SaveOptions,
	TextAffix,
	TextStampOptions,
} from "./types";
import * as fs from "fs";
import {
	getFileNames,
	getImageExtType,
	separateImageBufferOrImagePathInput,
	separatePdfInput,
} from "../internal/grpc_layer/util";

import {
	disposePdf,
	getBinaryData,
	openPdfFileBuffer,
} from "../internal/grpc_layer/pdfium/io";
import {
	mergePdfs,
	renderHtmlToPdf,
	renderHtmlZipToPdf,
	renderUrlToPdf,
} from "../internal/grpc_layer/chrome/render";

import {
	renderImagesBufferToPdf,
	renderImagesFilesToPdf,
} from "../internal/grpc_layer/chrome/image";
import {
	extractRawImages,
	rasterizeToImageBuffers,
} from "../internal/grpc_layer/pdfium/image";

import Jimp from "jimp";
import {
	duplicate,
	getPageInfo,
	insertPdf,
	removePage,
	resizePage,
	setPageRotation,
} from "../internal/grpc_layer/pdfium/page";
import {
	getPermission,
	removePasswordsAndEncryption,
	setOwnerPasswords,
	setSecurity,
	setUserPasswords,
} from "../internal/grpc_layer/pdfium/security";
import {
	stampBarcode,
	stampHtml,
	stampImage,
	stampText,
} from "../internal/grpc_layer/chrome/stamp";
import {toPdfA, toPdfUA} from "../internal/grpc_layer/pdfium/pdfa";
import { compressImage } from "../internal/grpc_layer/pdfium/compress";
import {
	getSignatureCount,
	signPdf,
} from "../internal/grpc_layer/pdfium/signing";
import {
	addHtmlAffix,
	addTextAffix,
} from "../internal/grpc_layer/pdfium/headerFooter";
import { addBackgroundForeground } from "../internal/grpc_layer/pdfium/BackgroundForeground";
import {extractAllText, replaceText} from "../internal/grpc_layer/pdfium/text";
import {
	getMetadataDict,
	removeMetadata,
	setMetadata,
	setMetadataDict,
} from "../internal/grpc_layer/pdfium/metadata";
import { Access } from "../internal/access";

/**
 * Represents a PDF document. Allows: loading, editing, manipulating, merging, signing printing and saving PDFs.
 *
 * @remark Make sure that you call {@link PdfDocument.close} or {@link cleanUp} to free the memory, when you stop using the PdfDocument object.
 */
export class PdfDocument {
	/**
	 * Internal PDF document ID
	 * @private
	 */
	private pdfDocumentId?: string;
	/**
	 * @private
	 */
	private readonly promiseDocumentId?: Promise<string>;
	/**
	 * @private
	 */
	private pdfPassword?: PdfPassword;

	/**
	 * Create a PdfDocument object from a {@link PdfInput}
	 * For more specific way to create/open PdfDocment see {@link fromUrl} {@link fromZip} {@link fromHtml} {@link fromImage}  {@link open}
	 *
	 * @param pdfInput see {@link PdfInput} (required)
	 * @param password a password to open the PDF required if PDF file was protected (pdfInput is {@link PdfFilePath} or {@link Buffer})
	 */
	constructor(pdfInput?: PdfInput, password?: PdfPassword) {
		if (pdfInput) {
			this.pdfDocumentId = undefined;

			const input = separatePdfInput(pdfInput);
			switch (input.type) {
				case "htmlFile":
					const htmlString = fs
						.readFileSync(input.htmlFile)
						.toString();
					this.promiseDocumentId = renderHtmlToPdf(htmlString);
					break;
				case "htmlString":
					this.promiseDocumentId = renderHtmlToPdf(input.htmlString);
					break;
				case "zipFile":
					this.promiseDocumentId = renderHtmlZipToPdf(input.zipFile);
					break;
				case "buffer":
					this.promiseDocumentId = openPdfFileBuffer(
						input.buffer,
						password
					);
					break;
				case "pdfFile":
					this.pdfPassword = password;
					this.promiseDocumentId = openPdfFileBuffer(
						fs.readFileSync(input.pdfFile),
						password
					);
					break;
				case "url":
					this.promiseDocumentId = renderUrlToPdf(input.url);
					break;
				case "pdfDocument":
					this.pdfDocumentId = input.pdfDocument.pdfDocumentId;
					this.promiseDocumentId =
						input.pdfDocument.promiseDocumentId;
					break;
			}
			if (this.pdfDocumentId) {
				Access.usedDocumentIds.add(this.pdfDocumentId);
			}
			this.promiseDocumentId?.then((id) =>
				Access.usedDocumentIds.add(id)
			);
		}
	}

	/**
	 * Dispose this PdfDocument object (clean up the resource)
	 * This is necessary to free the memory used by PdfDocument. See {@link cleanUp}
	 * Once this method was called this PdfDocument object no longer usable.
	 */
	public async close() {
		await disposePdf(await this.getId());
	}

	/**
	 * @private
	 */
	private async getId(): Promise<string> {
		if (this.pdfDocumentId) {
			return this.pdfDocumentId;
		} else if (this.promiseDocumentId) {
			this.pdfDocumentId = await this.promiseDocumentId;
			return this.pdfDocumentId;
		} else {
			throw new Error("Cannot Get PdfDocumentId");
		}
	}

	//#region io

	/**
	 * Open or Create a PdfDocument from a {@link PdfInput}
	 * @param pdfInput {@link PdfInput}
	 * @param options including {@link PdfPassword} {@link ChromePdfRenderOptions} {@link HttpLoginCredentials} mainHtmlFile
	 */
	public static async open(
		pdfInput: PdfInput,
		options?: {
			/**
			 * required for open a protected PDF file
			 * @default `undefined`
			 */
			password?: PdfPassword;
			/**
			 * Apply renderOptions if PdfInput is a {@link HtmlString} or {@link HtmlFilePath} or {@link ZipFilePath} or {@link Url}}
			 * @default `undefined`
			 */
			renderOptions?: ChromePdfRenderOptions;
			/**
			 * Apply httpLoginCredentials if PdfInput is a {@link HtmlString} or {@link HtmlFilePath} or {@link ZipFilePath} or {@link Url}}
			 * @default `undefined`
			 */
			httpLoginCredentials?: HttpLoginCredentials;
			/**
			 * Apply mainHtmlFile if PdfInput is {@link ZipFilePath}
			 * @default `index.html`
			 */
			mainHtmlFile?: string;
			// /**
			//  * Apply baseUrl if
			//  * The HTML base URL for which references to external CSS, Javascript and Image files will be relative.
			//  * @default `undefined`
			//  */
			// baseUrl?: string;  //not supported
		}
	): Promise<PdfDocument> {
		if (pdfInput) {
			const input = separatePdfInput(pdfInput);
			switch (input.type) {
				case "htmlFile":
					const htmlString = fs
						.readFileSync(input.htmlFile)
						.toString();
					const newHtmlFilePdf = new PdfDocument();
					newHtmlFilePdf.pdfDocumentId = await renderHtmlToPdf(
						htmlString,
						options?.renderOptions
					);
					return newHtmlFilePdf;
				case "htmlString":
					const newHtmlStringPdf = new PdfDocument();
					newHtmlStringPdf.pdfDocumentId = await renderHtmlToPdf(
						input.htmlString,
						options?.renderOptions
					);
					return newHtmlStringPdf;
				case "zipFile":
					const newZipFilePdf = new PdfDocument();
					newZipFilePdf.pdfDocumentId = await renderHtmlZipToPdf(
						input.zipFile,
						options?.mainHtmlFile,
						options?.renderOptions
					);
					return newZipFilePdf;
				case "buffer":
					const newBufferPdf = new PdfDocument(
						undefined,
						options?.password
					);
					newBufferPdf.pdfDocumentId = await openPdfFileBuffer(
						input.buffer,
						options?.password
					);
					return newBufferPdf;
				case "pdfFile":
					const newPdfFilePdf = new PdfDocument(
						undefined,
						options?.password
					);
					newPdfFilePdf.pdfDocumentId = await openPdfFileBuffer(
						fs.readFileSync(input.pdfFile),
						options?.password
					);

					return newPdfFilePdf;
				case "url":
					const newUrlPdf = new PdfDocument();
					newUrlPdf.pdfDocumentId = await renderUrlToPdf(input.url, {
						renderOptions: options?.renderOptions,
						httpLoginCredentials: options?.httpLoginCredentials,
					});
					return newUrlPdf;
				case "pdfDocument":
					return Promise.resolve(input.pdfDocument);
			}
		}
		throw new Error(`cannot create PdfDocument object from ${pdfInput}`);
	}

	/**
	 * Open a PdfDocument from .pdf file
	 * @param pdfFilePath A path to .pdf file
	 */
	public static async fromFile(
		pdfFilePath: string
	): Promise<PdfDocument> {
		return this.open(pdfFilePath);
	}

	/**
	 * Create a PdfDocument from an Url
	 * @param url A website Url
	 * @param options including {@link ChromePdfRenderOptions}
	 */
	public static async fromUrl(
		url: URL | string,
		options?: {
			/**
			 * Apply renderOptions if PdfInput is a {@link HtmlString} or {@link HtmlFilePath} or {@link ZipFilePath} or {@link Url}}
			 * @default `undefined`
			 */
			renderOptions?: ChromePdfRenderOptions;
		}
	): Promise<PdfDocument> {
		return this.open(url, options);
	}

	/**
	 * Creates a PDF file from a local Zip file, and returns it as a {@link PdfDocument}.
	 * IronPDF is a W3C standards compliant HTML rendering based on Google's Chromium browser.
	 * If your output PDF does not look as expected:
	 *
	 * - Validate your HTML file using  https://validator.w3.org/ &amp; CSS https://jigsaw.w3.org/css-validator/
	 *
	 * - To debug HTML, view the file in Chrome web browser's print preview which will work almost exactly as IronPDF.
	 *
	 * - Read our detailed documentation on pixel perfect HTML to PDF: https://ironpdf.com/tutorials/pixel-perfect-html-to-pdf/
	 *
	 * @param zipFilePath Path to a Zip to be rendered as a PDF.
	 * @param options including {@link ChromePdfRenderOptions} and `mainHtmlFile` a main .html file default: `index.html`
	 */
	public static async fromZip(
		zipFilePath: string,
		options?: {
			/**
			 * Apply renderOptions if PdfInput is a {@link HtmlString} or {@link HtmlFilePath} or {@link ZipFilePath} or {@link Url}}
			 * @default `undefined`
			 */
			renderOptions?: ChromePdfRenderOptions;
			/**
			 * a main .html file default: `index.html`
			 */
			mainHtmlFile?: string;
		}
	): Promise<PdfDocument> {
		return this.open(zipFilePath, options);
	}

	/**
	 * Creates a PDF file from a Html string, and returns it as an {@link PdfDocument} object which can be edited and saved to disk or served on a website.
	 * @param htmlStringOrHtmlFilePath The Html to be rendered as a PDF.
	 * @param options including {@link ChromePdfRenderOptions}
	 */
	public static async fromHtml(
		htmlStringOrHtmlFilePath: string,
		options?: {
			/**
			 * Apply renderOptions if PdfInput is a {@link HtmlString} or {@link HtmlFilePath} or {@link ZipFilePath} or {@link Url}}
			 * @default `undefined`
			 */
			renderOptions?: ChromePdfRenderOptions;
		}
	): Promise<PdfDocument> {
		return this.open(htmlStringOrHtmlFilePath, options);
	}

	/**
	 *  Converts multiple image files to a PDF document.  Each image creates 1 page which matches the image
	 *  dimensions. The default PaperSize is A4. You can set it via ImageToPdfConverter.PaperSize.
	 *  Note: Imaging.ImageBehavior.CropPage will set PaperSize equal to ImageSize.
	 * @param images The image file path name(s) or {@link ImageBuffer} object(s)
	 * @param options including {@link ImageToPdfOptions}
	 */
	public static async fromImage(
		images: ImageFilePath | ImageFilePath[] | ImageBuffer | ImageBuffer[],
		options?: {
			/**
			 * Apply renderOptions if PdfInput is a {@link HtmlString} or {@link HtmlFilePath} or {@link ZipFilePath} or {@link Url}}
			 * @default `undefined`
			 */
			imageToPdfOptions?: ImageToPdfOptions;
		}
	): Promise<PdfDocument> {
		let temp: Promise<string>;

		if (Array.isArray(images)) {
			// const imageArray = images as Array<any>;
			if (images.length == 0) {
				throw new Error("imageToPdf input Array is Empty");
			}

			const t = separateImageBufferOrImagePathInput(images[0]);

			switch (t.type) {
				case "imageBuffer":
					temp = renderImagesBufferToPdf(
						images as Buffer[],
						options?.imageToPdfOptions
					);
					break;
				case "imageFilePath":
					temp = renderImagesFilesToPdf(
						images as string[],
						options?.imageToPdfOptions
					);
					break;
			}
		} else {
			const image = separateImageBufferOrImagePathInput(images);
			switch (image.type) {
				case "imageBuffer":
					temp = renderImagesBufferToPdf(
						[image.imageBuffer],
						options?.imageToPdfOptions
					);
					break;
				case "imageFilePath":
					temp = renderImagesFilesToPdf(
						[image.imageFilePath],
						options?.imageToPdfOptions
					);
					break;
			}
		}

		if (!temp) {
			throw new Error(`cannot read image: ${images}`);
		}

		const newUrlPdf = new PdfDocument();
		newUrlPdf.pdfDocumentId = await temp;
		return newUrlPdf;
	}

	/**
	 * Static method that joins (concatenates) multiple PDF documents together into one compiled PDF document.
	 * If the PDF contains form fields the form field in the resulting PDF's name will be appended with '_{index}' e.g. 'Name' will be 'Name_0'
	 * @param pdfs array of PDF
	 */
	public static async mergePdf(pdfs: PdfInput[]): Promise<PdfDocument> {
		const ids = await Promise.all(
			pdfs.map(async (x) => (await PdfDocument.open(x)).getId())
		);
		const newDocId = mergePdfs(ids);
		const newUrlPdf = new PdfDocument();
		newUrlPdf.pdfDocumentId = await newDocId;
		return newUrlPdf;
	}

	/**
	 * Saves the PdfDocument to a file.
	 * @param filePath Target file path
	 * @param saveOptions see {@link SaveOptions}
	 */
	public saveAs(filePath: string, saveOptions?: SaveOptions): Promise<void> {
		return this.saveAsBuffer(saveOptions).then((pdfFileBuffer) => {
			fs.writeFile(filePath, pdfFileBuffer, "binary", (err) => {
				if (err) throw err;
			});
		});
	}

	/**
	 * Saves the PdfDocument to a binary (Buffer)
	 * @param saveOptions see {@link SaveOptions}
	 */
	public async saveAsBuffer(saveOptions?: SaveOptions): Promise<Buffer> {
		return getBinaryData(await this.getId(), saveOptions);
	}

	//#endregion

	//#region compress
	/**
	 * Compress existing PDF images using JPG encoding and the specified settings
	 * @param imageQuality Quality (1 - 100) to use during compression
	 * @param scaleToVisibleSize Scale down the image resolution according to its visible size in the PDF document
	 */
	public async compressSize(
		imageQuality: number,
		scaleToVisibleSize = false
	): Promise<void> {
		if (imageQuality < 1 || imageQuality > 100)
			throw new Error(
				`Invalid quality specifier (${imageQuality}) when compressing images. Quality must be between 1 and 100.`
			);
		return await compressImage(
			await this.getId(),
			imageQuality,
			scaleToVisibleSize
		);
	}

	//#endregion

	//#region page
	/**
	 * Gets information of all pages in the PdfDocument
	 */
	public async getPagesInfo(): Promise<PageInfo[]> {
		return await getPageInfo(await this.getId());
	}

	/**
	 * Gets the number of pages in the PdfDocument.
	 */
	public async getPageCount(): Promise<number> {
		return (await this.getPagesInfo()).length;
	}

	/**
	 * Set the page orientation.
	 * @param pageRotation see {@link PageRotation}
	 * @param options including {@link PdfPageSelection}
	 */
	public async setRotation(
		pageRotation: PageRotation,
		options?: {
			/**
			 * @default "all"
			 */
			pdfPageSelection?: PdfPageSelection;
		}
	) {
		return await setPageRotation(await this.getId(), pageRotation, options);
	}

	/**
	 * Resize a page to the specified dimensions
	 * @param newSize {@link PdfPaperSize}
	 * @param options including {@link PdfPageSelection}
	 */
	public async resize(
		newSize: PdfPaperSize,
		options?: {
			/**
			 * @default "all"
			 */
			PdfPageSelection?: PdfPageSelection;
		}
	): Promise<void> {
		return await resizePage(await this.getId(), newSize, options);
	}

	/**
	 * Adds another PDF to the beginning of the current PdfDocument
	 * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
	 * @param fromPdfDocument PdfDocument to prepend
	 */
	public async prependAnotherPdf(
		fromPdfDocument: PdfDocument
	): Promise<void> {
		await this.insertPagesFromAnotherPdf(fromPdfDocument, 0);
	}

	/**
	 * Appends another PDF to the end of the current <see cref="PdfDocument"/>
	 * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
	 * @param fromPdfDocument PdfDocument to Append
	 */
	public async appendAnotherPdf(fromPdfDocument: PdfDocument): Promise<void> {
		await this.insertPagesFromAnotherPdf(
			fromPdfDocument,
			(await this.getPageCount()) - 1
		);
	}

	/**
	 * Inserts another PDF into the current PdfDocument, starting at a given Page Index.
	 * If AnotherPdfFile contains form fields, those fields will be appended with '_' in the resulting PDF. e.g. 'Name' will be 'Name_'
	 * @param fromPdfDocument Another PdfDocument
	 * @param insertAtPageIndex Index at which to insert the new content.  Note: Page 1 has index 0...
	 */
	public async insertPagesFromAnotherPdf(
		fromPdfDocument: PdfDocument,
		insertAtPageIndex: number
	): Promise<void> {
		await insertPdf(
			await this.getId(),
			await fromPdfDocument.getId(),
			insertAtPageIndex
		);
	}

	/**
	 * Removes a range of pages from the PDF
	 * @param pages pages to remove
	 */
	public async removePage(pages: PdfPageSelection): Promise<void> {
		await removePage(await this.getId(), { PdfPageSelection: pages });
	}

	/**
	 * Creates a new PDF by copying a range of pages from this {@link PdfDocument}.
	 * @param pages pages to copy (default "all")
	 */
	public async duplicate(
		pages: PdfPageSelection = "all"
	): Promise<PdfDocument> {
		const newPdf = new PdfDocument();
		newPdf.pdfDocumentId = await duplicate(await this.getId(), {
			PdfPageSelection: pages,
		});
		return newPdf;
	}

	//#endregion

	//#region image
	/**
	 * Finds all embedded Images from within a specified pages in the PDF and returns them as Buffer
	 * @param options including {@link PdfPageSelection}
	 */
	public async extractRawImages(options?: {
		/**
		 * @default "all"
		 */
		fromPages: PdfPageSelection;
	}): Promise<Buffer[]> {
		return extractRawImages(
			await this.getId(),
			options?.fromPages ?? "all"
		);
	}

	/**
	 * Renders the PDF and exports image Files in convenient formats. 1 image file is created for each
	 * page.
	 *
	 * @param options including {@link PdfPageSelection} {@link ImageType}
	 *
	 * @return array of images as Buffer[]
	 */
	public async rasterizeToImageBuffers(options?: {
		/**
		 * @default "all"
		 */
		fromPages: PdfPageSelection;
		/**
		 * @default {@link ImageType.PNG}
		 */
		imageType?: ImageType;
	}): Promise<Buffer[]> {
		const images = await rasterizeToImageBuffers(
			await this.getId(),
			options?.fromPages ?? "all"
		);
		const jimpImageType: "image/bmp" | "image/png" | "image/jpeg" = (() => {
			switch (options?.imageType) {
				case ImageType.BMP:
					return Jimp.MIME_BMP;
				case ImageType.PNG:
					return Jimp.MIME_PNG;
				case ImageType.JPG:
					return Jimp.MIME_JPEG;
				default:
					return Jimp.MIME_PNG;
			}
		})();
		return Promise.all(
			images.map(async (imageBuffer) => {
				//convert output type
				const jimp = await Jimp.read(imageBuffer);
				return await jimp.getBufferAsync(jimpImageType);
			})
		);
	}

	/**
	 * Renders the PDF and exports image Files in convenient formats. 1 image file is created for each
	 * page. Running number will append output file path.
	 *
	 * @param filePath output file path.
	 * @param options including {@link PdfPageSelection} {@link ImageType}
	 *
	 * @return array of images file name as string[]
	 */
	public async rasterizeToImageFiles(
		filePath: string,
		options?: {
			/**
			 * @default "all"
			 */
			fromPages?: PdfPageSelection;
			/**
			 * @default {@link ImageType.PNG}
			 */
			type?: ImageType;
		}
	): Promise<string[]> {
		const images = await rasterizeToImageBuffers(
			await this.getId(),
			options?.fromPages ?? "all"
		);
		const filesName = getFileNames(
			filePath,
			images.length,
			getImageExtType(options?.type),
			"image"
		);

		const promises = images.map(async (imageBuffer, index) => {
			await Jimp.read(imageBuffer).then((value) =>
				value.write(filesName[index])
			);
			return filesName[index];
		});

		return await Promise.all(promises);
	}

	//#endregion

	//#region text
	/**
	 * Replace the specified old text with new text on a given page
	 * @param oldText Old text to remove
	 * @param newText New text to add
	 * @param onPages Page index to search for old text to replace (default "all")
	 */
	public async replaceText(
		oldText: string,
		newText: string,
		onPages?: PdfPageSelection
	): Promise<void> {
		return replaceText(await this.getId(), oldText, newText, onPages);
	}

	public async extractText(
		onPages?: PdfPageSelection
	): Promise<string> {
		return extractAllText(await this.getId(), onPages);
	}

	//#endregion

	//#region pdfA
	/**
	 * Convert the current document into the specified PDF-A standard format
	 * @param customICC (Optional) Custom color profile file path
	 */
	public async convertToPdfA(customICC?:string): Promise<void> {
		return await toPdfA(await this.getId(), customICC);
	}

	/**
	 * Convert the current document into the specified PDF/UA standard format
	 */
	public async convertToPdfUA(): Promise<void> {
		return await toPdfUA(await this.getId());
	}

	//#endregion

	//#region metadata
	/**
	 * Gets a Map<string, string> of metadata properties
	 */
	public async getMetadata(): Promise<Map<string, string>> {
		return getMetadataDict(await this.getId());
	}

	/**
	 * Add or Update a single metadata property
	 * @param key
	 * @param value
	 */
	public async addOrUpdateMetadata(
		key: string,
		value: string
	): Promise<void> {
		return setMetadata(await this.getId(), key, value);
	}

	/**
	 * Remove a single metadata property
	 * @param key
	 */
	public async removeMetadata(key: string): Promise<void> {
		return removeMetadata(await this.getId(), key);
	}

	/**
	 * Sets a whole metadata properties Map<string, string> (override all the metadata property)
	 * @param newMetadataDictionary new metadata properties Map<string, string>
	 */
	public async overrideMetadata(
		newMetadataDictionary: Map<string, string>
	): Promise<void> {
		return setMetadataDict(await this.getId(), newMetadataDictionary);
	}

	//#endregion

	//#region signing
	/**
	 * Sign PDF with digital signature certificate.
	 * Note that the PDF will not be fully signed until Saved
	 * using {@link saveAs} or {@link saveAsBuffer}
	 *
	 * Multiple certificates may be used.
	 * @param signature see {@link DigitalSignature}
	 */
	public async signDigitalSignature(signature: DigitalSignature) {
		return await signPdf(await this.getId(), signature);
	}

	/**
	 * Check if PdfDocument was signed or not
	 */
	public async isSigned(): Promise<boolean> {
		const signatureCount = await getSignatureCount(await this.getId());
		return signatureCount > 0;
	}

	/**
	 * Count the number signature that signed to this PdfDocument
	 */
	public async signatureCount(): Promise<number> {
		return await getSignatureCount(await this.getId());
	}

	//#endregion

	//#region header/footer (affix)
	/**
	 * Apply page header on top of an existing Pdf.
	 * @param header {@link TextAffix}
	 * @param toPages {@link PdfPageSelection}
	 */
	public async addTextHeader(
		header: TextAffix,
		toPages?: PdfPageSelection
	): Promise<void> {
		await addTextAffix(await this.getId(), toPages, header, true);
	}

	/**
	 * Apply page footer on top of an existing Pdf.
	 * @param footer {@link TextAffix}
	 * @param toPages {@link PdfPageSelection}
	 */
	public async addTextFooter(
		footer: TextAffix,
		toPages?: PdfPageSelection
	): Promise<void> {
		await addTextAffix(await this.getId(), toPages, footer, false);
	}

	/**
	 * Apply HTML header on top of an existing Pdf.
	 * @param header {@link HtmlAffix}
	 * @param toPages {@link PdfPageSelection}
	 */
	public async addHtmlHeader(
		header: HtmlAffix,
		toPages?: PdfPageSelection
	): Promise<void> {
		await addHtmlAffix(await this.getId(), toPages, header, true);
	}

	/**
	 * Apply HTML footer on top of an existing Pdf.
	 * @param footer {@link HtmlAffix}
	 * @param toPages {@link PdfPageSelection}
	 */
	public async addHtmlFooter(
		footer: HtmlAffix,
		toPages?: PdfPageSelection
	): Promise<void> {
		await addHtmlAffix(await this.getId(), toPages, footer, false);
	}

	//#endregion

	//#region stamp
	/**
	 * Edits the PDF by applying the HTML's rendered to only selected page(s).
	 * @param htmlStringOrHtmlFilePath
	 * @param options including {@link HtmlStampOptions} {@link PdfPageSelection}
	 */
	public async stampHtml(
		htmlStringOrHtmlFilePath: HtmlFilePath | HtmlString,
		options?: {
			htmlStampOptions?: HtmlStampOptions;
			toPages?: PdfPageSelection;
		}
	) {
		const html =
			htmlStringOrHtmlFilePath.endsWith(".html") ||
			htmlStringOrHtmlFilePath.endsWith(".htm")
				? fs.readFileSync(htmlStringOrHtmlFilePath).toString()
				: htmlStringOrHtmlFilePath;

		await stampHtml(await this.getId(), html, {
			password: this.pdfPassword,
			htmlStampOptions: options?.htmlStampOptions,
			pageSelection: options?.toPages,
		});
	}

	/**
	 * Edits the PDF by applying the image to only selected page(s).
	 * @param image image file path or image buffer
	 * @param options including {@link ImageStampOptions} {@link PdfPageSelection}
	 */
	public async stampImage(
		image: ImageFilePath | ImageBuffer,
		options?: {
			imageStampOptions?: ImageStampOptions;
			toPages?: PdfPageSelection;
		}
	) {
		const imageBuffer =
			image instanceof Buffer ? image : fs.readFileSync(image);

		await stampImage(await this.getId(), imageBuffer, {
			password: this.pdfPassword,
			options: options?.imageStampOptions,
			pageSelection: options?.toPages,
		});
	}

	/**
	 * Edits the PDF by applying the text to only selected page(s).
	 * @param text text to stamp
	 * @param options including {@link TextStampOptions} {@link PdfPageSelection}
	 */
	public async stampText(
		text: string,
		options?: {
			textStampOptions?: TextStampOptions;
			toPages?: PdfPageSelection;
		}
	) {
		await stampText(await this.getId(), text, {
			password: this.pdfPassword,
			options: options?.textStampOptions,
			pageSelection: options?.toPages,
		});
	}

	/**
	 * Edits the PDF by applying the barcode to only selected page(s).
	 * @param barcodeValue barcode
	 * @param options including {@link BarcodeType} {@link BarcodeStampOptions} {@link PdfPageSelection}
	 */
	public async stampBarcode(
		barcodeValue: string,
		options?: {
			barcodeEncoding: BarcodeType;
			barcodeStampOptions?: BarcodeStampOptions;
			toPages?: PdfPageSelection;
		}
	) {
		await stampBarcode(
			await this.getId(),
			barcodeValue,
			{
				password: this.pdfPassword,
				options: options?.barcodeStampOptions,
				pageSelection: options?.toPages,
			}
		);
	}

	//#endregion

	//#region background/foreground
	/**
	 * Adds a background to each page of this PDF. The background is copied from a first page in the
	 * backgroundPdf document.
	 *
	 * @param fromPdf background PDF document
	 * @param sourcePageIndex Index (zero-based page number) of the page to copy from the Background/Foreground PDF. Default is 0.
	 * @param applyToPages  PageSelection to which the background/foreground will be added. Default is "all"
	 */
	public async addBackgroundFromAnotherPdf(
		fromPdf: PdfDocument,
		sourcePageIndex = 0,
		applyToPages?: PdfPageSelection
	): Promise<void> {
		return await addBackgroundForeground(
			await this.getId(),
			await fromPdf.getId(),
			sourcePageIndex,
			true,
			applyToPages
		);
	}

	/**
	 * Adds a foreground to each page of this PDF. The background is copied from a first page in the
	 * backgroundPdf document.
	 *
	 * @param fromPdf foreground PDF document
	 * @param sourcePageIndex Index (zero-based page number) of the page to copy from the Background/Foreground PDF. Default is 0.
	 * @param applyToPages  PageSelection to which the background/foreground will be added. Default is "all"
	 */
	public async addForegroundFromAnotherPdf(
		fromPdf: PdfDocument,
		sourcePageIndex = 0,
		applyToPages?: PdfPageSelection
	): Promise<void> {
		return await addBackgroundForeground(
			await this.getId(),
			await fromPdf.getId(),
			sourcePageIndex,
			false,
			applyToPages
		);
	}

	//#endregion

	//#region security
	/**
	 * Removes all user and owner password security for a PDF document.  Also disables content
	 * encryption.
	 * If content is encrypted at 128 bit, copy and paste of content, annotations and form editing may be disabled.
	 */
	public async removePasswordsAndEncryption(): Promise<void> {
		await removePasswordsAndEncryption(await this.getId());
	}

	/**
	 * Sets the user password and enables 128Bit encryption of PDF content.
	 * A user password is a password that each user must enter to open or print the PDF document.
	 */
	public async setUserPassword(userPassword: string): Promise<void> {
		if (!this.pdfPassword)
			this.pdfPassword = { userPassword: userPassword };
		else this.pdfPassword.userPassword = userPassword;
		this.pdfDocumentId = await setUserPasswords(
			await this.getId(),
			userPassword
		);
	}

	/**
	 * Sets the owner password and enables 128Bit encryption of PDF content. An owner password is one used to
	 * enable and disable all other security settings. <para>OwnerPassword must be set to a non-empty string
	 * value for {@link PdfPermission.AllowAccessibilityExtractContent} ,  {@link PdfPermission.AllowAnnotations} ,
	 * {@link PdfPermission.AllowFillForms},  {@link PdfPermission.AllowPrint},  {@link PdfPermission.AllowModify} to be
	 * restricted.
	 */
	public async setOwnerPassword(ownerPassword: string): Promise<void> {
		if (!this.pdfPassword)
			this.pdfPassword = { ownerPassword: ownerPassword };
		else this.pdfPassword.ownerPassword = ownerPassword;
		this.pdfDocumentId = await setOwnerPasswords(
			await this.getId(),
			ownerPassword
		);
	}

	/**
	 * Sets the permissions of this PdfDocument
	 * @param permissions see {@link PdfPermission}
	 */
	public async setPermission(permissions: PdfPermission): Promise<void> {
		this.pdfDocumentId = await setSecurity(await this.getId(), permissions);
	}
	/**
	 * Gets the current permissions of this PdfDocument
	 * @return {@link PdfPermission}
	 */
	public async getPermission(): Promise<PdfPermission> {
		return await getPermission(await this.getId());
	}

	/**
	 * Makes this PDF document read only such that: Content is encrypted at 128 bit. Copy and paste of
	 * content is disallowed. Annotations and form editing are disabled.
	 * @param ownerPassword The owner password for the PDF. A string for owner password is required to enable PDF encryption and
	 * all document security options.
	 */
	public async makePdfDocumentReadOnly(ownerPassword: string): Promise<void> {
		await this.setOwnerPassword(ownerPassword);
		await this.setPermission({
			AllowExtractContent: false,
			AllowAccessibilityExtractContent: false,
			AllowAnnotations: false,
			AllowModify: false,
			AllowAssembleDocument: false,
			AllowFillForms: false,
		});
	}

	//#endregion
}
